<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Graph</title>

    <link href="datastruct.css" rel="stylesheet">
    <link href="proglang.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="prism.css" >
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  </head>
  <body class="bg-dark-subtle">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
      <div class="container-fluid">

        <div class="navbar-nav icon">
          <div class="logo-one">
            <i class="fa-solid fa-code logo"></i>
          </div>
          <div class="txt">
            <a class="nav-link active" aria-current="page" href="index.html">CodeQuick.in</a>
          </div>
        </div>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDarkDropdown" aria-controls="navbarNavDarkDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNavDarkDropdown">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Programming Languages
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="cpp.html">C++</a></li>
                <li><a class="dropdown-item" href="c.html">C</a></li>
                <li><a class="dropdown-item" href="python.html">Python</a></li>
              </ul>
            </li>
          </ul>
          
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Data Structures
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="arrays.html">Arrays</a></li>
                <li><a class="dropdown-item" href="strings.html">Strings</a></li>
                <li><a class="dropdown-item" href="linkedlist.html">Linked List</a></li>
                <li><a class="dropdown-item" href="stack.html">Stack</a></li>
                <li><a class="dropdown-item" href="queue.html">Queue</a></li>
                <li><a class="dropdown-item" href="dequeue.html">Deque</a></li>
                <li><a class="dropdown-item" href="hashing.html">Hash Table</a></li>
                <li><a class="dropdown-item" href="tree.html">Tree</a></li>
                <li><a class="dropdown-item" href="heap.html">Heap</a></li>
                <li><a class="dropdown-item" href="graph.html">Graph</a></li>
              </ul>
            </li>
          </ul>

          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Algorithms
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="searchin_sorting.html">Searching and Sorting</a></li>
                <li><a class="dropdown-item" href="two_pointer.html">Two Pointer</a></li>
                <li><a class="dropdown-item" href="prefix_sum.html">Prefix Sum</a></li>
                <li><a class="dropdown-item" href="kadane.html">Kadane</a></li>
                <li><a class="dropdown-item" href="kmp.html">KMP</a></li>
                <li><a class="dropdown-item" href="eucledian.html">Euclidean Algorithm for GCD</a></li>
                <li><a class="dropdown-item" href="hare.html">Hare and tortoise</a></li>
                <li><a class="dropdown-item" href="dikstra.html">Dijkstra's Algorithm</a></li>
                <li><a class="dropdown-item" href="bellman.html">Bellman-Ford Algorithm</a></li>
                <li><a class="dropdown-item" href="floyd.html">Floyd-Warshall Algorithm</a></li>
                <li><a class="dropdown-item" href="prims.html">Prim's Algorithm</a></li>
                <li><a class="dropdown-item" href="kruskal.html">Kruskal Algorithm</a></li>
              </ul>
            </li>
          </ul>

        </div>
      </div>
    </nav>

    <!-- HERO SECTION -->

    <div class="hero bg-dark-subtle">
      <h1 class="array-heading"><i class="fas fa-database icon"></i> Graph </h1>
      <h1 class="array-subheading"><i class="fas fa-info-circle icon"></i> BFS Traversal:</h1>
      <p class="array-text-one">
        A graph is a collection of <span class="highlight"> nodes (vertices) </span>and <span class="highlight"> edges </span>that connect pairs of nodes..
      </p>

      <div class="array-code ">
        <ul class=" nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link active" id="cpp-tab" data-bs-toggle="tab" href="#cpp-g1" role="tab" aria-controls="cpp" aria-selected="true">C++</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link" id="java-tab" data-bs-toggle="tab" href="#java-g1" role="tab" aria-controls="java" aria-selected="false">Java</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class="lang-clr nav-link" id="python-tab" data-bs-toggle="tab" href="#python-g1" role="tab" aria-controls="python" aria-selected="false">Python</a>
          </li>
        </ul>
      </div>

      <div class=" array-code tab-content" id="myTabContent">

        <div class="tab-pane fade show active" id="cpp-g1" role="tabpanel" aria-labelledby="cpp-tab">
          <pre>
            <code class="language-cpp">
                #include &lt;iostream&gt;
                #include &lt;vector&gt;
                #include &lt;queue&gt;
                #include &lt;unordered_set&gt;
                
                using namespace std;
                
                // Graph class representing adjacency list representation
                class Graph {
                    int V; // Number of vertices
                    vector<vector<int>> adj; // Adjacency list
                    
                public:
                    Graph(int V) {
                        this->V = V;
                        adj.resize(V);
                    }
                    
                    // Function to add an edge between two vertices
                    void addEdge(int v, int w) {
                        adj[v].push_back(w);
                    }
                    
                    // Function for BFS traversal
                    void BFS(int startVertex) {
                        // Mark all vertices as not visited
                        vector<bool> visited(V, false);
                        
                        // Create a queue for BFS
                        queue<int> q;
                        
                        // Mark the current node as visited and enqueue it
                        visited[startVertex] = true;
                        q.push(startVertex);
                        
                        while (!q.empty()) {
                            // Dequeue a vertex from the queue and print it
                            int currentVertex = q.front();
                            cout << currentVertex << " ";
                            q.pop();
                            
                            // Get all adjacent vertices of the dequeued vertex currentVertex
                            // If an adjacent vertex has not been visited, then mark it visited and enqueue it
                            for (int i = 0; i < adj[currentVertex].size(); ++i) {
                                int adjVertex = adj[currentVertex][i];
                                if (!visited[adjVertex]) {
                                    visited[adjVertex] = true;
                                    q.push(adjVertex);
                                }
                            }
                        }
                    }
                };
                
                // Driver program to test the above implementation
                int main() {
                    Graph g(5); // Create a graph with 5 vertices
                    g.addEdge(0, 1);
                    g.addEdge(0, 2);
                    g.addEdge(1, 3);
                    g.addEdge(1, 4);
                    g.addEdge(2, 4);
                    
                    cout << "BFS Traversal starting from vertex 0: ";
                    g.BFS(0);
                    
                    return 0;
                }                
                
            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="java-g1" role="tabpanel" aria-labelledby="java-tab">
          <pre>
            <code class="language-java">
              import java.util.*;

              // Graph class representing adjacency list representation
              class Graph {
                  private int V; // Number of vertices
                  private LinkedList<Integer>[] adj; // Adjacency list
                  
                  // Constructor
                  Graph(int V) {
                      this.V = V;
                      adj = new LinkedList[V];
                      for (int i = 0; i < V; ++i)
                          adj[i] = new LinkedList();
                  }
                  
                  // Function to add an edge between two vertices
                  void addEdge(int v, int w) {
                      adj[v].add(w);
                  }
                  
                  // Function for BFS traversal
                  void BFS(int startVertex) {
                      // Mark all vertices as not visited
                      boolean[] visited = new boolean[V];
                      
                      // Create a queue for BFS
                      LinkedList<Integer> queue = new LinkedList<Integer>();
                      
                      // Mark the current node as visited and enqueue it
                      visited[startVertex] = true;
                      queue.add(startVertex);
                      
                      while (queue.size() != 0) {
                          // Dequeue a vertex from the queue and print it
                          startVertex = queue.poll();
                          System.out.print(startVertex + " ");
                          
                          // Get all adjacent vertices of the dequeued vertex startVertex
                          // If an adjacent vertex has not been visited, then mark it visited and enqueue it
                          Iterator<Integer> i = adj[startVertex].listIterator();
                          while (i.hasNext()) {
                              int n = i.next();
                              if (!visited[n]) {
                                  visited[n] = true;
                                  queue.add(n);
                              }
                          }
                      }
                  }
                  
                  // Driver method to test above
                  public static void main(String args[]) {
                      Graph g = new Graph(5); // Create a graph with 5 vertices
                      g.addEdge(0, 1);
                      g.addEdge(0, 2);
                      g.addEdge(1, 3);
                      g.addEdge(1, 4);
                      g.addEdge(2, 4);
                      
                      System.out.println("BFS Traversal starting from vertex 0:");
                      g.BFS(0);
                  }
              }
              

            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="python-g1" role="tabpanel" aria-labelledby="python-tab">
          <pre>
            <code class="language-python">
              from collections import defaultdict, deque

              class Graph:
                  def __init__(self):
                      self.graph = defaultdict(list)
                  
                  def add_edge(self, u, v):
                      self.graph[u].append(v)
                  
                  def BFS(self, start_vertex):
                      visited = set()
                      queue = deque([start_vertex])
                      
                      while queue:
                          vertex = queue.popleft()
                          if vertex not in visited:
                              print(vertex, end=" ")
                              visited.add(vertex)
                              for neighbor in self.graph[vertex]:
                                  if neighbor not in visited:
                                      queue.append(neighbor)

              # Driver code to test above implementation
              g = Graph()
              g.add_edge(0, 1)
              g.add_edge(0, 2)
              g.add_edge(1, 3)
              g.add_edge(1, 4)
              g.add_edge(2, 4)

              print("BFS Traversal starting from vertex 0:")
              g.BFS(0)


            </code>
          </pre>
        </div>

      </div>

      
      <h1 class="array-subheading"><i class="fas fa-info-circle icon"></i> DFS traversal:</h1>

      <div class="array-code ">
        <ul class=" nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link active" id="cpp-tab" data-bs-toggle="tab" href="#cpp-g11" role="tab" aria-controls="cpp" aria-selected="true">C++</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link" id="java-tab" data-bs-toggle="tab" href="#java-g11" role="tab" aria-controls="java" aria-selected="false">Java</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class="lang-clr nav-link" id="python-tab" data-bs-toggle="tab" href="#python-g11" role="tab" aria-controls="python" aria-selected="false">Python</a>
          </li>
        </ul>
      </div>

      <div class=" array-code tab-content" id="myTabContent">


        <div class="tab-pane fade show active" id="cpp-g11" role="tabpanel" aria-labelledby="cpp-tab">
          <pre>
            <code class="language-cpp">
              
               #include &lt;iostream&gt;
                #include &lt;vector&gt;
                #include &lt;stack&gt;
                #include &lt;unordered_set&gt;
                
                using namespace std;
                
                // Graph class representing adjacency list representation
                class Graph {
                    int V; // Number of vertices
                    vector<vector<int>> adj; // Adjacency list
                    
                public:
                    Graph(int V) {
                        this->V = V;
                        adj.resize(V);
                    }
                    
                    // Function to add an edge between two vertices
                    void addEdge(int v, int w) {
                        adj[v].push_back(w);
                    }
                    
                    // Function for DFS traversal
                    void DFS(int startVertex) {
                        // Mark all vertices as not visited
                        vector<bool> visited(V, false);
                        
                        // Create a stack for DFS
                        stack<int> s;
                        
                        // Push the starting vertex onto the stack
                        s.push(startVertex);
                        
                        while (!s.empty()) {
                            // Pop a vertex from the stack and print it
                            int currentVertex = s.top();
                            s.pop();
                            
                            if (!visited[currentVertex]) {
                                cout << currentVertex << " ";
                                visited[currentVertex] = true;
                            }
                            
                            // Push all adjacent vertices that are not visited onto the stack
                            for (int i = 0; i < adj[currentVertex].size(); ++i) {
                                int adjVertex = adj[currentVertex][i];
                                if (!visited[adjVertex]) {
                                    s.push(adjVertex);
                                }
                            }
                        }
                    }
                };
                
                // Driver program to test the above implementation
                int main() {
                    Graph g(5); // Create a graph with 5 vertices
                    g.addEdge(0, 1);
                    g.addEdge(0, 2);
                    g.addEdge(1, 3);
                    g.addEdge(1, 4);
                    g.addEdge(2, 4);
                    
                    cout << "DFS Traversal starting from vertex 0: ";
                    g.DFS(0);
                    
                    return 0;
                }
                
                
            </code>
          </pre>
        </div>


        <div class="tab-pane fade" id="java-g11" role="tabpanel" aria-labelledby="java-tab">
          <pre>
            <code class="language-java">
              import java.util.*;

              // Graph class representing adjacency list representation
              class Graph {
                  private int V; // Number of vertices
                  private LinkedList<Integer>[] adj; // Adjacency list
                  
                  // Constructor
                  Graph(int V) {
                      this.V = V;
                      adj = new LinkedList[V];
                      for (int i = 0; i < V; ++i)
                          adj[i] = new LinkedList();
                  }
                  
                  // Function to add an edge between two vertices
                  void addEdge(int v, int w) {
                      adj[v].add(w);
                  }
                  
                  // Function for DFS traversal
                  void DFS(int startVertex) {
                      // Mark all vertices as not visited
                      boolean[] visited = new boolean[V];
                      
                      // Create a stack for DFS
                      Stack<Integer> stack = new Stack<Integer>();
                      
                      // Push the starting vertex onto the stack
                      stack.push(startVertex);
                      
                      while (!stack.empty()) {
                          // Pop a vertex from the stack and print it
                          startVertex = stack.pop();
                          if (!visited[startVertex]) {
                              System.out.print(startVertex + " ");
                              visited[startVertex] = true;
                          }
                          
                          // Push all adjacent vertices that are not visited onto the stack
                          Iterator<Integer> i = adj[startVertex].listIterator();
                          while (i.hasNext()) {
                              int n = i.next();
                              if (!visited[n]) {
                                  stack.push(n);
                              }
                          }
                      }
                  }
                  
                  // Driver method to test above
                  public static void main(String args[]) {
                      Graph g = new Graph(5); // Create a graph with 5 vertices
                      g.addEdge(0, 1);
                      g.addEdge(0, 2);
                      g.addEdge(1, 3);
                      g.addEdge(1, 4);
                      g.addEdge(2, 4);
                      
                      System.out.println("DFS Traversal starting from vertex 0:");
                      g.DFS(0);
                  }
              }


            </code>
          </pre>
        </div>
        

        <div class="tab-pane fade" id="python-g11" role="tabpanel" aria-labelledby="python-tab">
          <pre>
            <code class="language-python">
              from collections import defaultdict

              class Graph:
                  def __init__(self):
                      self.graph = defaultdict(list)
                  
                  def add_edge(self, u, v):
                      self.graph[u].append(v)
                  
                  def DFS(self, start_vertex):
                      visited = set()
                      stack = [start_vertex]
                      
                      while stack:
                          vertex = stack.pop()
                          if vertex not in visited:
                              print(vertex, end=" ")
                              visited.add(vertex)
                              for neighbor in reversed(self.graph[vertex]):
                                  if neighbor not in visited:
                                      stack.append(neighbor)

              # Driver code to test above implementation
              g = Graph()
              g.add_edge(0, 1)
              g.add_edge(0, 2)
              g.add_edge(1, 3)
              g.add_edge(1, 4)
              g.add_edge(2, 4)

              print("DFS Traversal starting from vertex 0:")
              g.DFS(0)



            </code>
          </pre>
        </div>

      </div>

    </div>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="prism.js"></script>
  </body>
</html>
