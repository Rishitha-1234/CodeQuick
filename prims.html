<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Prims Algorithm</title>

    <link href="datastruct.css" rel="stylesheet">
    <link href="proglang.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="prism.css" >
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  </head>

  <body class="bg-dark-subtle">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
      <div class="container-fluid">

        <div class="navbar-nav icon">
          <div class="logo-one">
            <i class="fa-solid fa-code logo"></i>
          </div>
          <div class="txt">
            <a class="nav-link active" aria-current="page" href="index.html">CodeQuick.in</a>
          </div>
        </div>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDarkDropdown" aria-controls="navbarNavDarkDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNavDarkDropdown">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Programming Languages
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="cpp.html">C++</a></li>
                <li><a class="dropdown-item" href="c.html">C</a></li>
                <li><a class="dropdown-item" href="python.html">Python</a></li>
              </ul>
            </li>
          </ul>
          
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Data Structures
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="arrays.html">Arrays</a></li>
                <li><a class="dropdown-item" href="strings.html">Strings</a></li>
                <li><a class="dropdown-item" href="linkedlist.html">Linked List</a></li>
                <li><a class="dropdown-item" href="stack.html">Stack</a></li>
                <li><a class="dropdown-item" href="queue.html">Queue</a></li>
                <li><a class="dropdown-item" href="dequeue.html">Deque</a></li>
                <li><a class="dropdown-item" href="hashing.html">Hash Table</a></li>
                <li><a class="dropdown-item" href="tree.html">Tree</a></li>
                <li><a class="dropdown-item" href="heap.html">Heap</a></li>
                <li><a class="dropdown-item" href="graph.html">Graph</a></li>
              </ul>
            </li>
          </ul>

          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Algorithms
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="searchin_sorting.html">Searching and Sorting</a></li>
                <li><a class="dropdown-item" href="two_pointer.html">Two Pointer</a></li>
                <li><a class="dropdown-item" href="prefix_sum.html">Prefix Sum</a></li>
                <li><a class="dropdown-item" href="kadane.html">Kadane</a></li>
                <li><a class="dropdown-item" href="kmp.html">KMP</a></li>
                <li><a class="dropdown-item" href="eucledian.html">Euclidean Algorithm for GCD</a></li>
                <li><a class="dropdown-item" href="hare.html">Hare and tortoise</a></li>
                <li><a class="dropdown-item" href="dikstra.html">Dijkstra's Algorithm</a></li>
                <li><a class="dropdown-item" href="bellman.html">Bellman-Ford Algorithm</a></li>
                <li><a class="dropdown-item" href="floyd.html">Floyd-Warshall Algorithm</a></li>
                <li><a class="dropdown-item" href="prims.html">Prim's Algorithm</a></li>
                <li><a class="dropdown-item" href="kruskal.html">Kruskal Algorithm</a></li>
                <li><a class="dropdown-item" href="kosaraju.html">Kosaraju's Algorithm</a></li>
              </ul>
            </li>
          </ul>

        </div>
      </div>
    </nav>

    <!-- HERO SECTION -->

    <div class="hero bg-dark-subtle">
        
      <h1 class="array-heading"><i class="fa-solid fa-sitemap"></i>Prims Algorithm:</h1>
      
      <p class="array-text-one">
        The algorithm begins with an<span class="highlight"> empty minimum spanning tree (MST) </span>and initializes two sets of vertices: one containing vertices already included in the MST and the other containing vertices yet to be included. Using a priority queue to keep track of the minimum weight edges, the algorithm iteratively selects the smallest edge that connects a vertex in the MST to a vertex outside it. Upon selecting an edge, it marks the corresponding vertex as included in the MST and updates the priority queue with the edges connected to this newly included vertex, ensuring the MST grows optimally at each step.
      </p>

      
      <div class="array-code ">
        <ul class=" nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link active" id="cpp-tab" data-bs-toggle="tab" href="#cpp-two1" role="tab" aria-controls="cpp" aria-selected="true">C++</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link" id="java-tab" data-bs-toggle="tab" href="#java-two1" role="tab" aria-controls="java" aria-selected="false">Java</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class="lang-clr nav-link" id="python-tab" data-bs-toggle="tab" href="#python-two1" role="tab" aria-controls="python" aria-selected="false">Python</a>
          </li>
        </ul>
      </div>

      <div class=" array-code tab-content" id="myTabContent">

        <div class="tab-pane fade show active" id="cpp-two1" role="tabpanel" aria-labelledby="cpp-tab">
          <pre>
            <code class="language-cpp">
                #include &lt;bits/stdc++.h&gt;
                using namespace std;

                class Solution {
                public:
                    // Function to find sum of weights of edges of the Minimum Spanning Tree.
                    int spanningTree(int V, vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; &adj) {
                        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;

                        vector&lt;int&gt; visited(V, 0);
                        pq.push({0, 0});  // {weight, node}
                        int totalWeight = 0;

                        while (!pq.empty()) {
                            auto [weight, node] = pq.top();
                            pq.pop();

                            if (visited[node]) continue;
                            visited[node] = 1;
                            totalWeight += weight;

                            for (auto &[adjNode, edgeWeight] : adj[node]) {
                                if (!visited[adjNode]) {
                                    pq.push({edgeWeight, adjNode});
                                }
                            }
                        }

                        return totalWeight;
                    }
                };

                int main() {
                    int V = 5;
                    vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; adj(V);

                    vector&lt;vector&lt;int&gt;&gt; edges = {
                        {0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}
                    };

                    for (const auto &edge : edges) {
                        adj[edge[0]].emplace_back(edge[1], edge[2]);
                        adj[edge[1]].emplace_back(edge[0], edge[2]);
                    }

                    Solution obj;
                    int totalWeight = obj.spanningTree(V, adj);
                    cout << "The sum of all the edge weights: " << totalWeight << endl;

                    return 0;
                }

                    
            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="java-two1" role="tabpanel" aria-labelledby="java-tab">
          <pre>
            <code class="language-java">
                import java.util.*;

                class Solution {
                    static class Edge implements Comparable&lt;Edge&gt; {
                        int weight;
                        int node;
                        
                        Edge(int weight, int node) {
                            this.weight = weight;
                            this.node = node;
                        }
                        
                        public int compareTo(Edge other) {
                            return this.weight - other.weight;
                        }
                    }
                    
                    public int spanningTree(int V, ArrayList&lt;ArrayList&lt;ArrayList&lt;Integer&gt;&gt;&gt; adj) {
                        PriorityQueue&lt;Edge&gt; pq = new PriorityQueue<>();
                        boolean[] visited = new boolean[V];
                        pq.add(new Edge(0, 0));
                        int totalWeight = 0;
                        
                        while (!pq.isEmpty()) {
                            Edge edge = pq.poll();
                            int node = edge.node;
                            int weight = edge.weight;
                            
                            if (visited[node]) continue;
                            visited[node] = true;
                            totalWeight += weight;
                            
                            for (ArrayList&lt;Integer&gt; neighbor : adj.get(node)) {
                                int adjNode = neighbor.get(0);
                                int edgeWeight = neighbor.get(1);
                                
                                if (!visited[adjNode]) {
                                    pq.add(new Edge(edgeWeight, adjNode));
                                }
                            }
                        }
                        return totalWeight;
                    }
                    
                    public static void main(String[] args) {
                        int V = 5;
                        ArrayList&lt;ArrayList&lt;ArrayList&lt;Integer&gt;&gt;&gt; adj = new ArrayList<>();
                        for (int i = 0; i < V; i++) {
                            adj.add(new ArrayList<>());
                        }
                
                        int[][] edges = {
                            {0, 1, 2}, {0, 2, 1}, {1, 2, 1}, {2, 3, 2}, {3, 4, 1}, {4, 2, 2}
                        };
                
                        for (int[] edge : edges) {
                            ArrayList&lt;Integer&gt; edge1 = new ArrayList<>(Arrays.asList(edge[1], edge[2]));
                            ArrayList&lt;Integer&gt; edge2 = new ArrayList<>(Arrays.asList(edge[0], edge[2]));
                            adj.get(edge[0]).add(edge1);
                            adj.get(edge[1]).add(edge2);
                        }
                
                        Solution obj = new Solution();
                        int totalWeight = obj.spanningTree(V, adj);
                        System.out.println("The sum of all the edge weights: " + totalWeight);
                    }
                }
                

            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="python-two1" role="tabpanel" aria-labelledby="python-tab">
          <pre>
            <code class="language-python">
              
                import heapq

                class Solution:
                    def spanningTree(self, V, adj):
                        pq = []
                        heapq.heappush(pq, (0, 0))  # (weight, node)
                        visited = [False] * V
                        total_weight = 0
                        
                        while pq:
                            weight, node = heapq.heappop(pq)
                            
                            if visited[node]:
                                continue
                            visited[node] = True
                            total_weight += weight
                            
                            for neighbor in adj[node]:
                                adj_node, edge_weight = neighbor
                                if not visited[adj_node]:
                                    heapq.heappush(pq, (edge_weight, adj_node))
                        
                        return total_weight
                
                # Driver code
                V = 5
                edges = [
                    [0, 1, 2], [0, 2, 1], [1, 2, 1], [2, 3, 2], [3, 4, 1], [4, 2, 2]
                ]
                
                adj = [[] for _ in range(V)]
                for edge in edges:
                    adj[edge[0]].append((edge[1], edge[2]))
                    adj[edge[1]].append((edge[0], edge[2]))
                
                obj = Solution()
                total_weight = obj.spanningTree(V, adj)
                print(f"The sum of all the edge weights: {total_weight}")
                
            </code>
          </pre>
        </div>

      </div>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="prism.js"></script>
  </body>
</html>
