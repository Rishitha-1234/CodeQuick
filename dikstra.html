<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Dijkstra</title>

    <link href="datastruct.css" rel="stylesheet">
    <link href="proglang.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="prism.css" >
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  </head>

  <body class="bg-dark-subtle">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
      <div class="container-fluid">

        <div class="navbar-nav icon">
          <div class="logo-one">
            <i class="fa-solid fa-code logo"></i>
          </div>
          <div class="txt">
            <a class="nav-link active" aria-current="page" href="index.html">CodeQuick.in</a>
          </div>
        </div>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDarkDropdown" aria-controls="navbarNavDarkDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNavDarkDropdown">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Programming Languages
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="cpp.html">C++</a></li>
                <li><a class="dropdown-item" href="c.html">C</a></li>
                <li><a class="dropdown-item" href="python.html">Python</a></li>
              </ul>
            </li>
          </ul>
          
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Data Structures
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="arrays.html">Arrays</a></li>
                <li><a class="dropdown-item" href="strings.html">Strings</a></li>
                <li><a class="dropdown-item" href="linkedlist.html">Linked List</a></li>
                <li><a class="dropdown-item" href="stack.html">Stack</a></li>
                <li><a class="dropdown-item" href="queue.html">Queue</a></li>
                <li><a class="dropdown-item" href="dequeue.html">Deque</a></li>
                <li><a class="dropdown-item" href="hashing.html">Hash Table</a></li>
                <li><a class="dropdown-item" href="tree.html">Tree</a></li>
                <li><a class="dropdown-item" href="heap.html">Heap</a></li>
                <li><a class="dropdown-item" href="graph.html">Graph</a></li>
              </ul>
            </li>
          </ul>

          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Algorithms
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="searchin_sorting.html">Searching and Sorting</a></li>
                <li><a class="dropdown-item" href="two_pointer.html">Two Pointer</a></li>
                <li><a class="dropdown-item" href="prefix_sum.html">Prefix Sum</a></li>
                <li><a class="dropdown-item" href="kadane.html">Kadane</a></li>
                <li><a class="dropdown-item" href="kmp.html">KMP</a></li>
                <li><a class="dropdown-item" href="eucledian.html">Euclidean Algorithm for GCD</a></li>
                <li><a class="dropdown-item" href="hare.html">Hare and tortoise</a></li>
                <li><a class="dropdown-item" href="dikstra.html">Dijkstra's Algorithm</a></li>
                <li><a class="dropdown-item" href="bellman.html">Bellman-Ford Algorithm</a></li>
                <li><a class="dropdown-item" href="floyd.html">Floyd-Warshall Algorithm</a></li>
                <li><a class="dropdown-item" href="prims.html">Prim's Algorithm</a></li>
                <li><a class="dropdown-item" href="kruskal.html">Kruskal Algorithm</a></li>
                <li><a class="dropdown-item" href="kosaraju.html">Kosaraju's Algorithm</a></li>
              </ul>
            </li>
          </ul>

        </div>
      </div>
    </nav>

    <!-- HERO SECTION -->

    <div class="hero bg-dark-subtle">
        
      <h1 class="array-heading"><i class="fa-solid fa-sitemap"></i>Dijkstra Algorithm:</h1>
      
      <p class="array-text-one">
        You have a connected, undirected graph with positive weights represented using an adjacency list adj. Each adj[i] contains lists where each sublist [j, w] signifies there's an edge between vertex i and vertex j with weight w. Given a source vertex S, your task is to compute and return a list of integers where each integer represents the shortest distance from the source vertex S to every other vertex in the graph.
      </p>

      <div class="array-code ">
        <ul class=" nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link active" id="cpp-tab" data-bs-toggle="tab" href="#cpp-two1" role="tab" aria-controls="cpp" aria-selected="true">C++</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link" id="java-tab" data-bs-toggle="tab" href="#java-two1" role="tab" aria-controls="java" aria-selected="false">Java</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class="lang-clr nav-link" id="python-tab" data-bs-toggle="tab" href="#python-two1" role="tab" aria-controls="python" aria-selected="false">Python</a>
          </li>
        </ul>
      </div>

      <div class=" array-code tab-content" id="myTabContent">

        <div class="tab-pane fade show active" id="cpp-two1" role="tabpanel" aria-labelledby="cpp-tab">
          <pre>
            <code class="language-cpp">
                
                #include &lt;iostream&gt;
                #include &lt;limits.h&gt;
                using namespace std;
                
                #define V 9 // Number of vertices in the graph
                
                // A utility function to find the vertex with minimum
                // distance value, from the set of vertices not yet included
                // in shortest path tree
                int minDistance(int dist[], bool sptSet[])
                {
                    // Initialize min value
                    int min = INT_MAX, min_index;
                
                    for (int v = 0; v < V; v++)
                        if (sptSet[v] == false && dist[v] <= min)
                            min = dist[v], min_index = v;
                
                    return min_index;
                }
                
                // A utility function to print the constructed distance
                // array
                void printSolution(int dist[])
                {
                    cout << "Vertex \t Distance from Source" << endl;
                    for (int i = 0; i < V; i++)
                        cout << i << " \t\t\t\t" << dist[i] << endl;
                }
                
                // Function that implements Dijkstra's single source
                // shortest path algorithm for a graph represented using
                // adjacency matrix representation
                void dijkstra(int graph[V][V], int src)
                {
                    int dist[V]; // The output array. dist[i] will hold the
                                    // shortest
                    // distance from src to i
                
                    bool sptSet[V]; // sptSet[i] will be true if vertex i is
                                    // included in shortest
                    // path tree or shortest distance from src to i is
                    // finalized
                
                    // Initialize all distances as INFINITE and sptSet[] as
                    // false
                    for (int i = 0; i < V; i++)
                        dist[i] = INT_MAX, sptSet[i] = false;
                
                    // Distance of source vertex from itself is always 0
                    dist[src] = 0;
                
                    // Find shortest path for all vertices
                    for (int count = 0; count < V - 1; count++)
                    {
                        // Pick the minimum distance vertex from the set of
                        // vertices not yet processed. u is always equal to
                        // src in the first iteration.
                        int u = minDistance(dist, sptSet);
                
                        // Mark the picked vertex as processed
                        sptSet[u] = true;
                
                        // Update dist value of the adjacent vertices of the
                        // picked vertex.
                        for (int v = 0; v < V; v++)
                
                            // Update dist[v] only if is not in sptSet,
                            // there is an edge from u to v, and total
                            // weight of path from src to  v through u is
                            // smaller than current value of dist[v]
                            if (!sptSet[v] && graph[u][v]
                                && dist[u] != INT_MAX
                                && dist[u] + graph[u][v] < dist[v])
                                dist[v] = dist[u] + graph[u][v];
                    }
                
                    // print the constructed distance array
                    printSolution(dist);
                }
                
                // driver's code
                int main()
                {
                
                    /* Let us create the example graph discussed above */
                    int graph[V][V] = { { 0, 4, 0, 0, 0, 0, 0, 8, 0 },
                                        { 4, 0, 8, 0, 0, 0, 0, 11, 0 },
                                        { 0, 8, 0, 7, 0, 4, 0, 0, 2 },
                                        { 0, 0, 7, 0, 9, 14, 0, 0, 0 },
                                        { 0, 0, 0, 9, 0, 10, 0, 0, 0 },
                                        { 0, 0, 4, 14, 10, 0, 2, 0, 0 },
                                        { 0, 0, 0, 0, 0, 2, 0, 1, 6 },
                                        { 8, 11, 0, 0, 0, 0, 1, 0, 7 },
                                        { 0, 0, 2, 0, 0, 0, 6, 7, 0 } };
                
                    // Function call
                    dijkstra(graph, 0);
                
                    return 0;
                }
                    
                    
            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="java-two1" role="tabpanel" aria-labelledby="java-tab">
          <pre>
            <code class="language-java">
                import java.util.*;

                class Solution {
                    static class Node implements Comparable&lt;Node&gt; {
                        int vertex;
                        int distance;
                        
                        public Node(int vertex, int distance) {
                            this.vertex = vertex;
                            this.distance = distance;
                        }
                        
                        public int compareTo(Node other) {
                            return Integer.compare(this.distance, other.distance);
                        }
                    }
                    
                    public int[] dijkstra(int V, List&lt;List&lt;int[]&gt;&gt; adj, int S) {
                        int[] dist = new int[V];
                        Arrays.fill(dist, Integer.MAX_VALUE);
                        dist[S] = 0;
                        
                        PriorityQueue&lt;Node&gt; pq = new PriorityQueue<>();
                        pq.offer(new Node(S, 0));
                        
                        while (!pq.isEmpty()) {
                            Node node = pq.poll();
                            int u = node.vertex;
                            
                            for (int[] neighbor : adj.get(u)) {
                                int v = neighbor[0];
                                int weight = neighbor[1];
                                
                                if (dist[u] != Integer.MAX_VALUE && dist[u] + weight < dist[v]) {
                                    dist[v] = dist[u] + weight;
                                    pq.offer(new Node(v, dist[v]));
                                }
                            }
                        }
                        
                        return dist;
                    }
                    
                    public static void main(String[] args) {
                        int V = 9;
                        List&lt;List&lt;int[]&gt;&gt; adj = new ArrayList<>();
                        
                        for (int i = 0; i < V; i++) {
                            adj.add(new ArrayList<>());
                        }
                        
                        adj.get(0).add(new int[]{1, 4});
                        adj.get(0).add(new int[]{7, 8});
                        adj.get(1).add(new int[]{0, 4});
                        adj.get(1).add(new int[]{2, 8});
                        adj.get(1).add(new int[]{7, 11});
                        adj.get(2).add(new int[]{1, 8});
                        adj.get(2).add(new int[]{3, 7});
                        adj.get(2).add(new int[]{4, 4});
                        adj.get(2).add(new int[]{8, 2});
                        adj.get(3).add(new int[]{2, 7});
                        adj.get(3).add(new int[]{4, 9});
                        adj.get(3).add(new int[]{5, 14});
                        adj.get(4).add(new int[]{3, 9});
                        adj.get(4).add(new int[]{5, 10});
                        adj.get(5).add(new int[]{2, 4});
                        adj.get(5).add(new int[]{3, 14});
                        adj.get(5).add(new int[]{6, 2});
                        adj.get(6).add(new int[]{5, 2});
                        adj.get(6).add(new int[]{7, 1});
                        adj.get(6).add(new int[]{8, 6});
                        adj.get(7).add(new int[]{0, 8});
                        adj.get(7).add(new int[]{1, 11});
                        adj.get(7).add(new int[]{6, 1});
                        adj.get(7).add(new int[]{8, 7});
                        adj.get(8).add(new int[]{2, 2});
                        adj.get(8).add(new int[]{6, 6});
                        adj.get(8).add(new int[]{7, 7});
                        
                        int S = 0;
                        Solution solution = new Solution();
                        int[] res = solution.dijkstra(V, adj, S);
                        
                        System.out.println("Vertex \t Distance from Source");
                        for (int i = 0; i < V; i++) {
                            System.out.println(i + "\t\t" + res[i]);
                        }
                    }
                }

                    

            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="python-two1" role="tabpanel" aria-labelledby="python-tab">
          <pre>
            <code class="language-python">

                import heapq
                from typing import List, Tuple

                class Solution:
                    def dijkstra(self, V: int, adj: List[List[List[int]]], S: int) -> List[int]:
                        # Initialize distance array with infinity
                        dist = [float('inf')] * V
                        dist[S] = 0
                        
                        # Min-heap priority queue
                        pq = [(0, S)]
                        
                        while pq:
                            d, u = heapq.heappop(pq)
                            
                            if d > dist[u]:
                                continue
                            
                            for v, w in adj[u]:
                                if dist[u] + w < dist[v]:
                                    dist[v] = dist[u] + w
                                    heapq.heappush(pq, (dist[v], v))
                        
                        return dist

                # Example usage:
                if __name__ == "__main__":
                    V = 9
                    adj = [
                        [[1, 4], [7, 8]],
                        [[0, 4], [2, 8], [7, 11]],
                        [[1, 8], [3, 7], [4, 4], [8, 2]],
                        [[2, 7], [4, 9], [5, 14]],
                        [[3, 9], [5, 10]],
                        [[2, 4], [3, 14], [6, 2]],
                        [[5, 2], [7, 1], [8, 6]],
                        [[0, 8], [1, 11], [6, 1], [8, 7]],
                        [[2, 2], [6, 6], [7, 7]]
                    ]
                    S = 0
                    solution = Solution()
                    res = solution.dijkstra(V, adj, S)
                    print("Vertex \t Distance from Source")
                    for i in range(V):
                        print(i, "\t\t", res[i])



            </code>
          </pre>
        </div>

      </div>

      
      

      </div>

    </div>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="prism.js"></script>
  </body>
</html>
