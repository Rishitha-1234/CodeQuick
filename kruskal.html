<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Kruskal Algorithm</title>

    <link href="datastruct.css" rel="stylesheet">
    <link href="proglang.css" rel="stylesheet">
    <link href="style.css" rel="stylesheet">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab:wght@100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="prism.css" >
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  </head>

  <body class="bg-dark-subtle">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark sticky-top">
      <div class="container-fluid">

        <div class="navbar-nav icon">
          <div class="logo-one">
            <i class="fa-solid fa-code logo"></i>
          </div>
          <div class="txt">
            <a class="nav-link active" aria-current="page" href="index.html">CodeQuick.in</a>
          </div>
        </div>

        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDarkDropdown" aria-controls="navbarNavDarkDropdown" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarNavDarkDropdown">
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Programming Languages
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="cpp.html">C++</a></li>
                <li><a class="dropdown-item" href="c.html">C</a></li>
                <li><a class="dropdown-item" href="python.html">Python</a></li>
              </ul>
            </li>
          </ul>
          
          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Data Structures
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="arrays.html">Arrays</a></li>
                <li><a class="dropdown-item" href="strings.html">Strings</a></li>
                <li><a class="dropdown-item" href="linkedlist.html">Linked List</a></li>
                <li><a class="dropdown-item" href="stack.html">Stack</a></li>
                <li><a class="dropdown-item" href="queue.html">Queue</a></li>
                <li><a class="dropdown-item" href="dequeue.html">Deque</a></li>
                <li><a class="dropdown-item" href="hashing.html">Hash Table</a></li>
                <li><a class="dropdown-item" href="tree.html">Tree</a></li>
                <li><a class="dropdown-item" href="heap.html">Heap</a></li>
                <li><a class="dropdown-item" href="graph.html">Graph</a></li>
              </ul>
            </li>
          </ul>

          <ul class="navbar-nav me-auto mb-2 mb-lg-0">
            <li class="nav-item dropdown">
              <button class="btn btn-dark dropdown-toggle" data-bs-toggle="dropdown" aria-expanded="false">
                Algorithms
              </button>
              <ul class="dropdown-menu dropdown-menu-dark">
                <li><a class="dropdown-item" href="searchin_sorting.html">Searching and Sorting</a></li>
                <li><a class="dropdown-item" href="two_pointer.html">Two Pointer</a></li>
                <li><a class="dropdown-item" href="prefix_sum.html">Prefix Sum</a></li>
                <li><a class="dropdown-item" href="kadane.html">Kadane</a></li>
                <li><a class="dropdown-item" href="kmp.html">KMP</a></li>
                <li><a class="dropdown-item" href="eucledian.html">Euclidean Algorithm for GCD</a></li>
                <li><a class="dropdown-item" href="hare.html">Hare and tortoise</a></li>
                <li><a class="dropdown-item" href="dikstra.html">Dijkstra's Algorithm</a></li>
                <li><a class="dropdown-item" href="bellman.html">Bellman-Ford Algorithm</a></li>
                <li><a class="dropdown-item" href="floyd.html">Floyd-Warshall Algorithm</a></li>
                <li><a class="dropdown-item" href="prims.html">Prim's Algorithm</a></li>
                <li><a class="dropdown-item" href="kruskal.html">Kruskal Algorithm</a></li>
                <li><a class="dropdown-item" href="kosaraju.html">Kosaraju's Algorithm</a></li>
              </ul>
            </li>
          </ul>

        </div>
      </div>
    </nav>

    <!-- HERO SECTION -->

    <div class="hero bg-dark-subtle">
        
      <h1 class="array-heading"><i class="fa-solid fa-sitemap"></i>Kruskal Algorithm:</h1>
      
      <p class="array-text-one">
        The algorithm begins with an<span class="highlight"> empty minimum spanning tree (MST) </span>and initializes two sets of vertices: one containing vertices already included in the MST and the other containing vertices yet to be included. Using a priority queue to keep track of the minimum weight edges, the algorithm iteratively selects the smallest edge that connects a vertex in the MST to a vertex outside it. Upon selecting an edge, it marks the corresponding vertex as included in the MST and updates the priority queue with the edges connected to this newly included vertex, ensuring the MST grows optimally at each step.
      </p>

      
      <div class="array-code ">
        <ul class=" nav nav-tabs" id="myTab" role="tablist">
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link active" id="cpp-tab" data-bs-toggle="tab" href="#cpp-two1" role="tab" aria-controls="cpp" aria-selected="true">C++</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class=" lang-clr nav-link" id="java-tab" data-bs-toggle="tab" href="#java-two1" role="tab" aria-controls="java" aria-selected="false">Java</a>
          </li>
          <li class="nav-item" role="presentation">
            <a class="lang-clr nav-link" id="python-tab" data-bs-toggle="tab" href="#python-two1" role="tab" aria-controls="python" aria-selected="false">Python</a>
          </li>
        </ul>
      </div>

      <div class=" array-code tab-content" id="myTabContent">

        <div class="tab-pane fade show active" id="cpp-two1" role="tabpanel" aria-labelledby="cpp-tab">
          <pre>
            <code class="language-cpp">
                    #include &lt;iostream&gt;
                    #include &lt;vector&gt;
                    #include &lt;algorithm&gt;
                    using namespace std;
                    
                    class DisjointSet {
                    private:
                        vector&lt;int&gt; parent, rank, size;
                    
                    public:
                        DisjointSet(int n) {
                            parent.resize(n + 1);
                            rank.resize(n + 1, 0);
                            size.resize(n + 1, 1);
                            for (int i = 0; i <= n; ++i) {
                                parent[i] = i;
                            }
                        }
                    
                        int find(int u) {
                            if (parent[u] != u) {
                                parent[u] = find(parent[u]);
                            }
                            return parent[u];
                        }
                    
                        void unionBySize(int u, int v) {
                            int rootU = find(u);
                            int rootV = find(v);
                    
                            if (rootU != rootV) {
                                if (size[rootU] < size[rootV]) {
                                    swap(rootU, rootV);
                                }
                                parent[rootV] = rootU;
                                size[rootU] += size[rootV];
                            }
                        }
                    };
                    
                    class Solution {
                    public:
                        int kruskalMST(int V, vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt;& edges) {
                            sort(edges.begin(), edges.end()); // Sort edges by weight
                            DisjointSet ds(V);
                            int mstWeight = 0;
                            for (auto edge : edges) {
                                int weight = edge.first;
                                int u = edge.second.first;
                                int v = edge.second.second;
                    
                                if (ds.find(u) != ds.find(v)) {
                                    mstWeight += weight;
                                    ds.unionBySize(u, v);
                                }
                            }
                            return mstWeight;
                        }
                    };
                    
                    int main() {
                        int V = 5;
                        vector&lt;pair&lt;int, pair&lt;int, int&gt;&gt;&gt; edges = {{2, {0, 1}}, {1, {0, 2}}, {1, {1, 2}}, {2, {2, 3}}, {1, {3, 4}}, {2, {2, 4}}};
                    
                        Solution obj;
                        int mstWeight = obj.kruskalMST(V, edges);
                        cout << "Minimum Spanning Tree Weight: " << mstWeight << endl;
                    
                        return 0;
                    }
                    
            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="java-two1" role="tabpanel" aria-labelledby="java-tab">
          <pre>
            <code class="language-java">
                import java.util.*;

                class DisjointSet {
                    private int[] parent;
                    private int[] rank;
                    private int[] size;

                    public DisjointSet(int n) {
                        parent = new int[n + 1];
                        rank = new int[n + 1];
                        size = new int[n + 1];
                        for (int i = 0; i <= n; ++i) {
                            parent[i] = i;
                            size[i] = 1;
                        }
                    }

                    public int find(int u) {
                        if (parent[u] != u) {
                            parent[u] = find(parent[u]);
                        }
                        return parent[u];
                    }

                    public void unionBySize(int u, int v) {
                        int rootU = find(u);
                        int rootV = find(v);

                        if (rootU != rootV) {
                            if (size[rootU] < size[rootV]) {
                                int temp = rootU;
                                rootU = rootV;
                                rootV = temp;
                            }
                            parent[rootV] = rootU;
                            size[rootU] += size[rootV];
                        }
                    }
                }

                class Solution {
                    public int kruskalMST(int V, List&lt;int[]&gt; edges) {
                        Collections.sort(edges, (a, b) -> Integer.compare(a[0], b[0])); // Sort edges by weight
                        DisjointSet ds = new DisjointSet(V);
                        int mstWeight = 0;
                        for (int[] edge : edges) {
                            int weight = edge[0];
                            int u = edge[1];
                            int v = edge[2];

                            if (ds.find(u) != ds.find(v)) {
                                mstWeight += weight;
                                ds.unionBySize(u, v);
                            }
                        }
                        return mstWeight;
                    }
                }

                public class Main {
                    public static void main(String[] args) {
                        int V = 5;
                        List&lt;int[]&gt; edges = new ArrayList<>();
                        edges.add(new int[]{2, 0, 1});
                        edges.add(new int[]{1, 0, 2});
                        edges.add(new int[]{1, 1, 2});
                        edges.add(new int[]{2, 2, 3});
                        edges.add(new int[]{1, 3, 4});
                        edges.add(new int[]{2, 2, 4});

                        Solution obj = new Solution();
                        int mstWeight = obj.kruskalMST(V, edges);
                        System.out.println("Minimum Spanning Tree Weight: " + mstWeight);
                    }
                }


            </code>
          </pre>
        </div>

        <div class="tab-pane fade" id="python-two1" role="tabpanel" aria-labelledby="python-tab">
          <pre>
            <code class="language-python">
                class DisjointSet:
                    def __init__(self, n):
                        self.rank = [0] * (n + 1)
                        self.parent = list(range(n + 1))
                        self.size = [1] * (n + 1)

                    def findUPar(self, node):
                        if node == self.parent[node]:
                            return node
                        self.parent[node] = self.findUPar(self.parent[node])
                        return self.parent[node]

                    def unionByRank(self, u, v):
                        ulp_u = self.findUPar(u)
                        ulp_v = self.findUPar(v)
                        if ulp_u == ulp_v:
                            return
                        if self.rank[ulp_u] < self.rank[ulp_v]:
                            self.parent[ulp_u] = ulp_v
                        elif self.rank[ulp_v] < self.rank[ulp_u]:
                            self.parent[ulp_v] = ulp_u
                        else:
                            self.parent[ulp_v] = ulp_u
                            self.rank[ulp_u] += 1

                    def unionBySize(self, u, v):
                        ulp_u = self.findUPar(u)
                        ulp_v = self.findUPar(v)
                        if ulp_u == ulp_v:
                            return
                        if self.size[ulp_u] < self.size[ulp_v]:
                            self.parent[ulp_u] = ulp_v
                            self.size[ulp_v] += self.size[ulp_u]
                        else:
                            self.parent[ulp_v] = ulp_u
                            self.size[ulp_u] += self.size[ulp_v]

                class Solution:
                    def kruskalMST(self, V, edges):
                        edges.sort()  # Sort edges based on weight
                        ds = DisjointSet(V)
                        mstWt = 0
                        mstEdges = []

                        for wt, u, v in edges:
                            if ds.findUPar(u) != ds.findUPar(v):
                                mstWt += wt
                                mstEdges.append((u, v, wt))
                                ds.unionBySize(u, v)

                        return mstWt, mstEdges

                # Example usage:
                if __name__ == "__main__":
                    V = 5
                    edges = [(2, 0, 1), (1, 0, 2), (1, 1, 2), (2, 2, 3), (1, 3, 4), (2, 2, 4)]
                    obj = Solution()
                    mstWeight, mstEdges = obj.kruskalMST(V, edges)
                    print("Minimum Spanning Tree Weight:", mstWeight)
                    print("Minimum Spanning Tree Edges:", mstEdges)

            </code>
          </pre>
        </div>

      </div>


    </div>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.7/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
    <script src="prism.js"></script>
  </body>
</html>
